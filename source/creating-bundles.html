<title>Creating bundles</title>
<link rel="Up" href="index.html" title="nosh Guide" />
<link rel="Next" href="converting-systemd-units.html" title="Converting systemd units" />
<link rel="Prev" href="anatomy-of-sysinit-service.html" title="Anatomy of a sysinit service" />
<h1>
Creating bundles
</h1>

<p>
If you are unlucky enough to have a package that does not supply service bundle directories for its services, you have some options.
</p>

<h2>
You can build a bundle using parts from some public <code>run</code> script collections.
</h2>

<p>
<a href="http://smarden.org/runit/runscripts.html">Gerrit Pape made a collection of some run scripts some years ago.</a>
<a href="http://thedjbway.b0llix.net/services.html">Wayne Marshall has collected a few more.</a>
<a href="http://kdegraaf.net/supervise.html">So has Kevin J. DeGraaf.</a>
<a href="http://gluelogic.com/code/daemontools/examples.shtml">And so has Glenn Strauss.</a>
Simply take an appropriate <code>run</code> script, add minimal <code>start</code>, <code>stop</code>, and <code>restart</code> programs, put the lot into a <code>service</code> directory, put that into a bundle directory, and enable/start the service.
</p>

<p>
Minimal <code>start</code>, <code>stop</code>, and <code>restart</code> scripts are simply:
</p>
<blockquote><pre>#!/bin/nosh
true</pre></blockquote>

<p>
Note that Gerrit Pape's and Wayne Marshall's collections use shells as the script interpreters.
Several of the scripts can be simplified <em>yet further</em> with use of <code>nosh</code> and its built-in toolset.
Some of them also rely upon tools such as <code>chpst</code> and <code>tcpsvd</code>, which one of course replaces with the equivalent daemontools-alike tool(s) and some combination of <a href="tcp-socket-listen.html"><code>tcp-socket-listen</code></a>, <a href="tcp-socket-accept.html"><code>tcp-socket-accept</code></a>, and <a href="ucspi-socket-rules-check.html"><code>ucspi-socket-rules-check</code></a>.
</p>

<h2>
You can import a systemd <em>service unit</em> file.
</h2>

<p>
<a href="converting-systemd-units.html">
If the package comes with a systemd service unit file (and potentially an accompanying socket unit file), you can import it.</a>
Simply run <code>system-control convert-systemd-units <i>servicename</i></code> and the import utility will attempt to import the service and write a bundle directory.
(You can control where the bundle directory is written.)
This can cope with many systemd service units, as long as they aren't Linux-specific, esoteric, or too clever by half.
</p>

<p>
The import utility will display warnings about anything that it didn't understand or ignored.
</p>

<h2>
You can simply write a bundle.
</h2>

<p>
As mentioned above, minimal <code>start</code>, <code>stop</code>, and <code>restart</code> scripts are very simple.
So, too, are <code>run</code> scripts.
</p>

<p>
The service interdependencies and orderings are usually quite simple, too:
</p>
<blockquote><pre>mkdir -p wants after before stopped-by wanted-by
ln -s /etc/service-bundles/targets/basic after/
ln -s /etc/service-bundles/targets/basic wants/
ln -s /etc/service-bundles/targets/shutdown before/
ln -s /etc/service-bundles/targets/shutdown stopped-by/
ln -s /etc/service-bundles/targets/workstation wanted-by/</pre></blockquote>

<p>
Tailor this according to need, of course.
</p>

<p>
The standard targets are akin to the Solaris SMF milestones, including having distinct "server", "workstation", and "multi-user" targets instead of one single target that mixes all three.
Some other SMF non-milestone services have similar standard target equivalents: "system/filesystem/local" being equivalent to <code>local-fs</code> for example.
</p>

<p>
The NetBSD <code>rc.d</code> system has some milestones that do not really correspond well; in part because this package's standard targets are intended to promote more parallelism than NetBSD <code>rc.d</code>.
A rough guide for converting from NetBSD <code>rc.d</code> is:
</p>

<dl>
<dt><code>FILESYSTEMS</code></dt>
<dd><p>
<code>BEFORE FILESYSTEMS</code> does not occur out of the box in BSDs.
<code>REQUIRES FILESYSTEMS</code> is equivalent to <code>wants/</code> and <code>after/</code> the <code>local-fs</code> standard target.
</p></dd>
<dt><code>SERVERS</code></dt>
<dd><p>
This is rarely used out of the box in BSDs.
<code>BEFORE SERVERS</code> usually means being <code>wanted-by/</code> one of the <code>workstation</code>, <code>server</code>, or <code>sysinit</code> standard targets.
There's little distinction in practice beween <code>REQUIRES SERVERS</code> and <code>REQUIRES DAEMON</code>; with how to convert the latter usually also applying to the former.
</p></dd>
<dt><code>DAEMON</code></dt>
<dd><p>
A service that <code>REQUIRES DAEMON</code> usually simply <code>wants/</code> the <code>basic</code> standard target and is <code>stopped-by/</code> the <code>shutdown</code> standard target.
However <code>basic</code> is not an ordering milestone.
On the gripping hand, a service that is <code>BEFORE DAEMON</code> is usually actually expressing the notion that it is <code>wanted-by/</code> a standard target within <code>basic</code> such as <code>sysinit</code>.
</p></dd>
<dt><code>NETWORKING</code></dt>
<dd><p>
The idea of "networking" is a very woolly one that doesn't really admit of one single description.
Rather than relate things to such an ill-defined milestone, relate them to the more specific things that they in reality relate to, such as a default route becoming available, static networking being initialized, individual interfaces coming up, any interface heving carrier, or all networking interfaces having carrier.
</p></dd>
<dt><code>LOGIN</code></dt>
<dd><p>
This is somewhat woolly, like <code>NETWORKING</code>.
Deferring things until "after the system is secure" should be done by ordering them with respect to services such as <code>securelevel</code> if it should be done at all.
Moreover, the fact that "login services" are held off until the system has waited for pretty much everything else to finish, including services that take a long time to initialize but that would not actually prohibit log-on, is a significant problem with the very idea of this ordering milestone.
</p><p>
TTY login services generally order themselves <code>after/</code> other specific services (e.g. <code>hostname</code>) rather than standard targets.
</p></dd>
</dl>
